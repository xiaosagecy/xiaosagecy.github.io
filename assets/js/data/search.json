[ { "title": "My first blog", "url": "/posts/%E7%AC%AC%E4%B8%80%E4%B8%AAblog/", "categories": "随笔", "tags": "生活", "date": "2022-03-26 02:34:00 +0000", "snippet": "感谢关注～//代码片段int main(){ hello world;}" }, { "title": "JS基础面试题", "url": "/posts/JS%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB/", "categories": "随笔", "tags": "生活", "date": "2022-03-26 02:34:00 +0000", "snippet": "JS预解析什么是预解析?JS代码在执行之前，解析引擎会对代码进行一个预先的检查，主要会对变量和函数的声明进行提升，将变量和函数的声明提到代码的最前面.变量只提升声明，不提升赋值.// 变量提升：坑1console.log(num);var num = 10;// 结果输出： undefined// 执行过程：浏览器会把变量和函数声明在当前作用域下提到最前面，但是不会进行赋值// 上面代码执行过程相当于：var num;console.log(num); // 所以此处输出的num为undefinednum = 10;// 变量提升：坑2 函数表达式fun();var fun = function() { console.log(22);}// 相当于执行了以下代码var fun;fun(); // fun is not a function 因为先执行 var fun ，fun 是一个变量 而不是函数fun = function() { console.log(22);}// 函数提升fn();function fn() { console.log(11);}// 相当于执行了下面代码：// 函数提升function fn() { console.log(11);}fn();function fn() { console.log(11);} 经典面试题// 写出结果f1();console.log(c);console.log(b);console.log(a);function f1() { var a = b = c = 9; // 相当于 var a = 9;b = 9; c = 9; b，c没用声明直接赋值为全局变量 console.log(a); console.log(b); console.log(c);}// 相当于执行了function f1() { var a; // 因为只声明了 var a 所以a 是在函数里面的局部变量 a = 9; b = 9; // 没用声明 直接赋值则是全局变量 b,c均为全局变量 c = 9; console.log(a); // 9 console.log(b); // 9 console.log(c); // 9}f1();console.log(c); // 9console.log(b); // 9console.log(a); // a is not defined// 区分 var a = b = c = 9 //相当于 var a = 9;b = 9; c = 9;// 集体声明var a = 9, b = 9, c = 9 //相当于 var a = 9;var b = 9; var c = 9;构造函数构造函数本质也是一个函数，只不过这个函数在定义的时候首字母般需要大写;构造函数调用的时候,必须通过一个new关键字来调用;我们一般不直接使用构造函数，而是使用构造函数创建出来的实例对象.构造函数是js面向对象的一个重要组成部分。和Java中new一个对象差不多Javapublic class User { private String name; private int age;}// 提供getter和setter方法// new 一个对象User user = new User(&quot;小明&quot;,18)JavaScript// 利用构造函数创建对象function Animal(uname,age) { this.name = uname; this.age = age;}const dog = new Animal(&#39;小灰灰&#39;,1);// 检测dog的类型console.log(typeof dog) // Objectconsole.log(dog.name) // 小灰灰console.log(dog.age) // 1遍历对象（for…in）const dog = { name: &#39;小灰灰&#39;, age: 3, hobby: &#39;啃骨头&#39; } // 遍历对象 使用for...in for(let key in dog) { console.log(key) // key 为对象中的属性名 name,age,hobby console.log(dog[key]) // dog[key] 为对象中的属性值 小灰灰， 3， 啃骨头 }date对象格式化格式化日期：年-月-日 -星期const now = new Date(); console.log(now); // 格式化日期：年-月-日 -星期 const year = now.getFullYear(); const month = now.getMonth()+1; // 注意：月份放回的是0-11月，所以要+1 const date = now.getDate(); const day = now.getDay(); // 放回0-6 :0为周日 6为周六 const arr = [&#39;星期日&#39;,&#39;星期一&#39;,&#39;星期二&#39;,&#39;星期三&#39;,&#39;星期四&#39;,&#39;星期五&#39;,&#39;星期六&#39;]; console.log(`${year}年${month}月${date}日 ${arr[day]}`); // 2022年6月5日 星期日格式化 时:分:秒// 封装一个函数 格式化 时:分:秒 const getTime = () =&amp;gt; { const now = new Date(); let h = now.getHours(); h = h &amp;lt; 10 ? &#39;0&#39; + h : h; let m = now.getMinutes(); m = m &amp;lt; 10 ? &#39;0&#39; + m : m; let s = now.getSeconds(); s = s &amp;lt; 10 ? &#39;0&#39; + s : s; return `${h}:${m}:${s}` } console.log(getTime());//14:53:32// h5新增时间戳 console.log(Date.now()); //1654412012912数组操作push:将元素添加到数组的末尾，返回值是数组长度pop:将数组最后一个元素删除，返回值是被删除的元素unshift:在数组的开头插入一个元素,返回值是数组的长度shift:将数组第一个元素删除，返回值是被删除的元素splice (index, len) :删除数组中指定元素concat:连接数组reverse:翻转数组数组排序sort内置sort对数组进行排序默认排序是按照码点排序会出错解决方法：使用的时候用函数方式给它传入两个函数a和b return a-b 排序为升序 ，return b-a 排序为降序const array = [85,24,75,19,50]console.log(array.sort(function(a,b){ return a-b; // 升序排序 降序排序 return b-a;})); // [19, 24, 50, 75, 85]数组去重// 数组去重 // 1.定义一个新数组 // 2.遍历就数组，把不重复的值存入新数组中 使用indexOf去判读 indexOf为-1就是找不到值 // 如果新数组中找不到旧数组的值 newArr.indexOf(arr[i]) === -1 就把元素存到新数组里 const arr = [1,3,1,4,5,3,8] const unique = (array) =&amp;gt; { let newArr = [] for(let i = 0 ;i &amp;lt; array.length; i++){ if(newArr.indexOf(arr[i]) === -1){ newArr.push(arr[i]) } } return newArr } const res = unique(arr) console.log(res)数组与字符串互相转换数组转换为字符串// 1. toString() 将我们的数组转换为字符串var arr = [1, 2, 3];console. log(arr .toString()); // 1,2,3// 2. join(分隔符)var arr1 = [&#39; green&#39; ,&#39;blue&#39;, &#39;pink&#39;];console.1og(arr1.join()); // green, blue，pinkconsole.1og(arr1.join(&#39;-&#39;)); // green-blue-pinkconsole. log(arr1.join(&#39;&amp;amp;&#39; )); // green&amp;amp;blue&amp;amp;pink字符串转换为数组// 字符转换为数组split(&#39;分隔符&#39;)var str2 = &#39;red, pink, blue&#39;;console.log(str2.split(&#39;,&#39;)); // [&#39;red, pink, blue&#39;]var str3 = &#39; red&amp;amp;pink&amp;amp;blue&#39;;console.log(str3.split(&#39;&amp;amp;&#39;)); // [&#39;red, pink, blue&#39;]数组中的splice删除const arr = [1,2,3,4,5]const res = arr.splice(0,2) // 第一个参数是下标，第二参数是删除的长度console.log(res) // 返回值是删除的元素 [1,2]console.log(arr) // 删除后的数组 [3,4,5]添加const arr = [1,2,3,4,5]// 添加一个元素// 第一个参数是下标，第二参数是删除的长度，第三个参数是插入的新元素const res = arr.splice(1,0,9) // 把9添加在下标为1的地方，其余元素往后移一位console.log(arr)[1, 9, 2, 3, 4, 5]找出数组中某个元素出现位置及次数面试题 // [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;, &#39; green&#39;, &#39;pink&#39; ,&#39;red&#39;],求red出现的位置和次数 const arr = [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;, &#39; green&#39;, &#39;pink&#39; ,&#39;red&#39;] let index = arr.indexOf(&#39;red&#39;) let num = 0; while(index != -1) { console.log(index); // red出现位置下标 0 2 5 num ++ ; index = arr.indexOf(&#39;red&#39;,index+1) } console.log(&#39;red出现的次数&#39;+num);// red出现次数 3 var str =&#39;aaabbbbbccddddddddddddddx&#39;; var index = str.indexOf(&#39;d&#39;); var num = 0; while(index != -1) { console.log(index); index = str.indexOf(&#39;d&#39;,index+1) num ++ } // 打印d出现的次数 console.log(&#39;d出现的次数:&#39;+num);JS延迟加载延迟加载: async、 defer例如: &amp;lt;script defer type=&quot;text/javascript&quot; src= &#39; script.js&#39;&amp;gt;&amp;lt;/script&amp;gt;或 &amp;lt;script async type=&quot;text/javascript&quot; src= &#39; script.js&#39;&amp;gt;&amp;lt;/script&amp;gt;defer :等html全部解析完成，才会执行js代码，顺次执行js脚本。async : async是和html解析同步的(一起的)，不是 顺次执行js脚本(谁 先加载完谁先执行)。JS的数据类型有那些基本类型: string、 number、 boolean、 undefined、 null、symbol、 bigint(可以不答)引用类型: objectNaN是一个数值类型， 但是不是一个具体的数字。console.log(true+1) // 2 ture是Boolean类型相加时 true为1 false为2console.log(&#39;name&#39;+true) // nametrue 字符串与任何类型相加后均为字符串类型console.log(undefined+1) // NaN NaN是数值类型--&amp;gt;number类型console.log(typeof null) // Object null就是对象类型console.log(typeof(NaN)) // numberconsole.log(typeof(undefined)) // undefinedJS中null与undefined的区别JavaScript的最初版本是这样区分的:null 是一个 表示“无”的对象(空对象指针),转为数值时为0;undefined是一个表示”无”的原始值，转为数值时为NaN. NaN（Not a Number，非数）是计算机科学中数值数据类型的一类值，表示未定义或不可表示的值。常在浮点数运算中使用。首次引入NaN的是1985年的IEEE 754浮点数标准JS中“==”与“===”的区别 ==只会对值进行比较,通常使用valueOf进行比较。 ===不仅会对值进行比较,还会对数据类型进行比较。 （开发中尽量使用“===”）宏任务和微任务执行流程：同步=&amp;gt;事件循环=&amp;gt;微任务=&amp;gt;宏任务=&amp;gt;微任务…执行宏任务前先要完成微任务// 宏任务 setTimeout(() =&amp;gt; { console.log(1) }) new Promise((resolve) =&amp;gt; { console.log(&#39;1 promise&#39;) // 同步 resolve() }).then(() =&amp;gt; { console.log(&#39;微任务1&#39;) }).then(() =&amp;gt; { console.log(&#39;微任务2&#39;) }) console.log(2)// 输出结果：1 promise、2、微任务1、微任务2、1图片来源于知乎JS作用域考题// 记住JS有变量提升var bar = 1;function test() { console.log(bar); // undefined var bar = 2; console.log(bar); // 2}test();// 以上代码相当于 var bar = 1;function test() { var bar; console.log(bar); // bar没用赋值 输出 undefined bar = 2; console.log(bar); // bar赋值了 输出 2}test();var name = &#39;a&#39;;(function(){ if(typeof name == &#39;undefined&#39;){ var name = &#39;b&#39;; console.log(&#39;111&#39;+name); }else{ console.log(&#39;222&#39;+name); }})()// 以上代码相当于var name = &#39;a&#39;; // 这个是迷惑(function(){ var name; if(typeof name == &#39;undefined&#39;){ name = &#39;b&#39;; console.log(&#39;111&#39;+name); }else{ console.log(&#39;222&#39;+name); }})()// 结果输出：111b// 注意：先看函数内有没用变量，如果有先提升变量再做出判读找出多维数组的最大值 function fnArr(arr) { var newArr = []; arr.forEach((item,index) =&amp;gt; { // Math.max() 函数返回一组数中的最大值。 newArr.push(Math.max(...item)) }) return newArr; } var array = [ [4,5,1,3], [13,27,18,26], [32,35,37,39], [1000,1001,857,1] ] console.log(fnArr(array)); // [5, 27, 39, 1001]JS charAt() 方法charAt() 方法可返回指定位置的字符。第一个字符位置为 0, 第二个字符位置为 1,以此类推.var str = &quot;HELLO WORLD&quot;;var n = str.charAt(2);console.loog(n); // L闭包闭包：函数嵌套函数，内部函数就是闭包正常情况下，函数执行完成，内部变量会销毁（释放内存空间）闭包内部的函数没用执行完成，外部函数变量不会被销毁*闭包的作用:闭包可以延展一个函数的作用域*注意事项:不能滥用闭包，会导致内存泄漏function outerFun() { let a = 10; function innerFun() { console.log(a); // 10 } return innerFun;}let fun = outerFun();fun();原型链1.原型可以解决什么问题： 对象共享属性和共享方法2.谁有原型 函数拥有: prototype 对象拥有: _ proto _3.对象查找属性或者方法的顺序 先在对象本身查找–&amp;gt; 构造函数中查找–&amp;gt; 对象的原型(_ _proto _ _)–&amp;gt;构造函数的原型中(prototype)–&amp;gt;当前原型(Object)4.原型链 4.1是什么? :就是把原型串联起来 4.2原型链的最顶端是nullJS中的继承ES6之前官方并没有提供一种实现继承的语法，所以大部分继承方式都是程序员通过代码在模拟.常见的继承方式有以下几种:原型继承;借用构造函数继承;组合继承;ES6之后使用extends 关键字实现继承(class Student extends Person{})call、apply、bind区别共同点：功能一致 可以改变this的指向语法： 函数.call()、函数.apply()、函数.bind()区别：1.call、apply可以立即执行。bind不会立即执行，因为bind返回的是一个函数需要加入()执行。​ 2.参数不同：apply第二个参数是数组。call和bind有多个参数需要一个一个写。 function fn() { console.log(this) // 此时this指向Window }// 接下来改变fn的this指向var obj = {str:&#39;我是obj中的this&#39;}function fn() { console.log(this) } fn.call(obj) //this指向obj 输出 {str: &#39;我是obj中的this&#39;} fn.apply(obj) //this指向obj 输出 {str: &#39;我是obj中的this&#39;} fn.bind(obj)()//this指向obj 输出 {str: &#39;我是obj中的this&#39;} fn() // window fn.bind(obj)输出的是: ƒ fn() { console.log(this) } 需要在后面加上括号才会执行 var obj = {str:&#39;我是obj中的this&#39;} function fn(name,age) { this.name = name this.age = age console.log(this) // {str: &#39;我是obj中的this&#39;, name: &#39;张三&#39;, age: 22} 下面三个方式输出相同结构，参数有所区别 } // fn.call(obj,&#39;张三&#39;,22) // fn.apply(obj,[&#39;张三&#39;,22]) fn.bind(obj,&#39;张三&#39;,22)()JSON.parse()把字符串转为对象 // JSON.parse()把字符串转化为JS对象 var str = &#39;{ &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; }&#39; var obj = JSON.parse(str) console.log(obj) // {name: &#39;runoob&#39;, alexa: 10000, site: &#39;www.runoob.com&#39;}JSON.stringify()把对象转为字符串 var obj = { &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot;}; var myStr = JSON.stringify(obj) console.log(typeof myStr) // string console.log(myStr)浅拷贝与深拷贝浅拷贝：如果数组A拷贝一份给数组B,如果数组A中第一个元素改变，数组B中第一个数组元素也发生改变 称为浅拷贝 （引用地址）深拷贝：把A的值复制一份给B,B的改变不会影响A 称为深拷贝 (把值真正地复制一份，如果发生改变只修改复制数据内容，不影响原数据)浅拷贝 const arrA = [&#39;1&#39;,&#39;3&#39;,&#39;4&#39;] const arrB = arrA // arrB改变会影响arrA 为浅拷贝 arrB[0] = &#39;拷贝&#39; console.log(arrA); // [&#39;拷贝&#39;, &#39;3&#39;, &#39;4&#39;] console.log(arrB); // [&#39;拷贝&#39;, &#39;3&#39;, &#39;4&#39;]// 或者var obj1 ={a:1,b:2}var obj2 = Object.assign(obj1)深拷贝 var obj = {a:1,b:2} var obj2 = JSON.parse(JSON.stringify(obj)) // obj2改变不影响obj 为深拷贝 因为是真正的把obj拷贝出去再修改的 所以为深拷贝 obj2.a = 3 console.log(obj) // {a: 1, b: 2} console.log(obj2)// {a: 3, b: 2}sessionStorage、localStorage、cookie的区别公共点：在客户端存放数据区别： 数据存放的有效期 sessionStorage： 仅在当前浏览器窗口关闭前有效。【关闭浏览器就没了】 localStorage ： 始终有效，窗口或者浏览器关闭也一直保存，所以叫持久化存储。【需要手动删除】 cookie ： 只有在设置的cookie过期时间之前有效，即使窗口或者浏览器关闭也有效。【需要是localhost等线上环境才可以设置，本地的 D://code … 这些设置不了】 localStorage、sessionStorage 不可以设置过期时间 cookie 有过期时间，也可以设置过期时间（把时间调整到之前的时间，就过期了） 存储大小的限制 cookie 存储量不能超过4K sessionStorage 存储量相对较少5M左右 local Storage 存储量大20M左右 ** 根据不同浏览器存储的大小是不同的 " } ]
